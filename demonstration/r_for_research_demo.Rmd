---
title: "R Programming for Research Demonstration"
author: "Nicholas Michalak"
date: "6/24/2017"
output:
  html_document: 
    code_folding: show
    fig_height: 7.5
    fig_width: 10.5
    keep_md: yes
    theme: readable
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

# load packages

```{r}

# packages I want to use in this analysis
want_packages <- c("tidyverse", "psych", "haven", "lavaan", "lme4", "lmerTest", "afex", "compute.es")

# packages I have
have_packages <- want_packages %in% rownames(installed.packages())

# install those I don"t have
if(any(!have_packages))
  install.packages(want_packages[!have_packages])

# lapply stands for "list" apply and it applies a function (this case, the library function) over a list of objects or a vector (in this case, the vector of character vector of package names)
# I can give it an argument from the library function
lapply(want_packages, library, character.only = TRUE)

```

# generate data for examples

```{r}
# create four variables: N, x, z, and y
# 100 observations per variable
N <- 100
id <- 1:100

# set randomizer seed so results can be reproduced
set.seed(1234)

# drawn from random normal distribution
x <- rnorm(n = N, mean = 175, sd = 7)
z <- 0.7 * x + rnorm(n = N, mean = 0, sd = 5)
y <- 0.4 * z + rnorm(n = N, mean = 0, sd = 5)

# store in a dataframe
my_data <- data.frame(id, y, x, z)

```

# descriptives

```{r}

my_data %>%
  psych::describe(.)

```

# correlation matrix

```{r}

my_data %>%
  select(-id) %>%
  pairs.panels(pch = ".")

```

# histograms

```{r}

my_data %>%
  gather(variable, value, -id) %>%
  ggplot() +
  geom_histogram(aes(x = value)) +
  facet_wrap(~ variable, nrow = 3)

```

# boxplots

```{r}

my_data %>%
  gather(variable, value, -id) %>%
  ggplot(aes(x = variable, y = value)) +
  geom_boxplot()

```

# scatterplots

```{r}

my_data %>%
  ggplot(aes(x = x, y = z)) +
  geom_point() +
  geom_smooth(method = "lm")

my_data %>%
  ggplot(aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(method = "lm")

my_data %>%
  ggplot(aes(x = z, y = y)) +
  geom_point() +
  geom_smooth(method = "lm")

```

# correlation tests

```{r}

my_data %>%
  select(-id) %>%
  corr.test() %>%
  print(short = FALSE)

```

# principal components analysis

```{r}
my_data %>%
  select(-id) %>%
  principal()
```

# exploratory factor analysis

```{r}

my_data %>%
  select(-id) %>%
  fa()

```

# t-tests

```{r}
t.test(x, y)
t.test(x, z)
t.test(z, y)

```

# classic ANOVA

```{r}

my_data %>%
  gather(variable, value, -id) %>%
  mutate(id = 1:300) %>%
  aov_car(formula = value ~ variable + Error(id), data = .) %>%
  summary(.)

```

# folow up contrasts (classic ANOVA)

```{r}

my_data %>%
  gather(variable, value, -id) %>%
  mutate(id = 1:300) %>%
  aov_car(formula = value ~ variable + Error(id), data = .) %>%
  lsmeans::lsmeans(specs = "variable") %>%
  contrast(list(xy = c(-1, 1, 0),
                xz = c(-1, 0, 1),
                yz = c(0, -1, 1))) %>%
  confint(.)

```

# effect sizes

```{r}

mes(m.1 = mean(x),
    m.2 = mean(y),
    sd.1 = sd(x),
    sd.2 = sd(y),
    n.1 = length(x),
    n.2 = length(y),
    level = .95,
    verbose = TRUE)

```

# classic repeated measures ANOVA

```{r}

my_data %>%
  gather(variable, value, -id) %>%
  aov_car(formula = value ~ variable + Error(id/variable), data = .) %>%
  summary(.)

```

# follow-up contrasts (classic RM ANOVA)

```{r}

my_data %>%
  gather(variable, value, -id) %>%
  aov_car(formula = value ~ variable + Error(id/variable), data = .) %>%
  lsmeans::lsmeans(specs = "variable") %>%
  contrast(list(xy = c(-1, 1, 0),
                xz = c(-1, 0, 1),
                yz = c(0, -1, 1))) %>%
  confint(.)
  
```

# mediation

```{r}

# path label combes before variable
# e.g. z ~ a * x = label = regress z on x, label it a
my_mediaition <- "# a path
                    z ~ a * x

                  # b path
                    y ~ b * z

                  # c path
                    y ~ c * x

                  # print total and indirect effects
                    ab := a * b
                    total := c + (a * b)"

# fit model
my_mediaition %>%
  sem(data = my_data) %>%
  summary(.)

# parameter estimates with boostraped CIs
my_mediaition %>%
  sem(data = my_data,
      se = "bootstrap",
      bootstrap = 1000) %>%
  parameterEstimates(boot.ci.type = "bca.simple")

```

# moderated regression

```{r}

my_data %>%
  lm(y ~ x * z, data = .) %>%
  summary(.)

```

## custom function for testing simple slopes

```{r}

# simple slopes function
test_slopes <- function(y, x, z, sd_values = seq(-3, 3, 0.5), mean_center = TRUE, alpha = .05) {
  
  # Computes confidence intervals and test statistics at given moderator values (defaults to -3 SD to 3 SD)
  # Arguments: 
  #   y:           continuous outcome variable
  #   x:           continuous predictor variable
  #   z:           moderator variable (can be continuous or categorical but MUST be numeric or integer)
  #   sd_values:   standard deviation multipliers of z for testing slopes
  #   mean_center: center x and y around the their means (default set to TRUE)
  #   alpha:       alpha level for 1-alpha confidence
  # Returns:
  #   some data descriptives and table of values for each of three tests: sd values for z, estimates, standard errors, t-statistics, p-values, and lower and upper confidence intervals
  
  if(mean_center == TRUE) {
    x <- x - mean(x, na.rm = TRUE)
    z <- z - mean(z, na.rm = TRUE)
  }
  
  # matrix of descriptives
  descriptives <- sapply(list(y = y, x = x, z = z), function(v) {
    round(c(N = sum(is.na(v) == FALSE),
    Mean = mean(v, na.rm = TRUE),
    SD = sd(v, na.rm = TRUE),
    Median = median(v, na.rm = TRUE),
    Min = min(v, na.rm = TRUE),
    Max = max(v, na.rm = TRUE)), digits = 3)
    })

  # fit model
  model <- lm(y ~ x * z)
  
  # mean of z
  z_mean <- mean(z, na.rm = TRUE)
  
  # sd of z
  z_sd <- sd(z, na.rm = TRUE)
  
  # model covariance matrix
  model_vcov <- vcov(model)
  
  est <- list()
  se <- list()
  for(i in 1:length(sd_values)) {
    
    est[[i]] <- coefficients(model)["x"] + coefficients(model)["x:z"] * (z_mean + sd_values[i] * z_sd)
    se[[i]] <- sqrt(model_vcov["x", "x"] + 2 * (z_mean + sd_values[i] * z_sd) * model_vcov["x", "x:z"] + (z_mean + sd_values[i] * z_sd) * (z_mean + sd_values[i] * z_sd) * model_vcov["x:z", "x:z"])
    
  }
  
  # result table: estimates and standard errors
  result <- data.frame(z_sd = sd_values * descriptives[3, 3],
                       est = unlist(est),
                       se = unlist(se))
  
  # t-statistics
  result$t_val <- with(data = result, est / se)
  
  # p-values
  result$p_val <- with(data = result, 2 * pt(q = -abs(t_val), df = model$df.residual))
  
  # t-critical
  t_crit <- qt(p = 1 - alpha / 2, df = model$df.residual)
  
  # lower confidence intervals
  result$lwr_ci <- with(data = result, est - t_crit * se)
  
  # upper confidence intervals
  result$upr_ci <- with(data = result, est + t_crit * se)
  
  # round all values to 3 digits (except p-values, which should be exact)
  result[, !colnames(result) %in% "p_val"] <- data.frame(apply(result[, !colnames(result) %in% "p_val"], 2, function(i) round(i, 3)))
  
  print(paste0("Descriptives"))
  print(descriptives)
  return(result)
}

```

## simple slopes

```{r}

test_slopes(y = y,
            x = x,
            z = z,
            sd_values = seq(-3, 3, 0.5),
            mean_center = TRUE,
            alpha = .05)

```

# linear mixed effects model

```{r}

# model summary
my_data %>%
  gather(variable, value, -id) %>%
  lmer(formula = value ~ variable + (1 | id), data = .) %>%
  summary(.)

```
